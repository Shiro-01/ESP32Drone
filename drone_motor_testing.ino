/***************************************************
  This code integrates the MPU6050 sensor with PID control
  and RemoteXY GUI for joystick-based motor control.
  It includes automatic calibration of the MPU6050 sensor.
  
  Hardware:
  - DFRduino Nano V3.1
  - MPU6050 sensor
  - Four ESCs controlling motors connected via Servo objects
  
  Libraries Required:
  - Wire.h (built-in)
  - Servo.h (built-in)
  - Adafruit_MPU6050.h
  - Adafruit_Sensor.h
  - RemoteXY.h
  - Kalman.h (for Kalman filter; optional, as we use a complementary filter)
***************************************************/

// Include necessary libraries
#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Servo.h>


// RemoteXY configuration
#define REMOTEXY_MODE__ESP8266_HARDSERIAL_POINT
#define REMOTEXY_SERIAL Serial
#define REMOTEXY_SERIAL_SPEED 115200
#define REMOTEXY_WIFI_SSID "shiro"
#define REMOTEXY_WIFI_PASSWORD "12345678"
#define REMOTEXY_SERVER_PORT 6377

// RemoteXY GUI configuration
// This configuration is generated by the RemoteXY editor
// Replace the following configuration with your own if needed
#include <RemoteXY.h>

// RemoteXY GUI configuration  
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 54 bytes
  { 255,5,0,0,0,47,0,18,0,0,0,31,1,106,200,1,1,3,0,5,
  12,18,49,49,32,2,26,31,5,15,121,49,49,32,2,26,31,2,56,79,
  44,22,1,2,26,31,31,79,78,0,79,70,70,0 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  int8_t joystick_01_x; // from -100 to 100
  int8_t joystick_01_y; // from -100 to 100
  int8_t joystick_02_x; // from -100 to 100
  int8_t joystick_02_y; // from -100 to 100
  uint8_t switch_01; // =1 if switch ON and =0 if OFF

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   
#pragma pack(pop)

// Global variables
Adafruit_MPU6050 mpu;
Servo esc1, esc2, esc3, esc4;

// PID variables
float RatePitch, RateRoll, RateYaw;
float DesiredRateRoll, DesiredRatePitch, DesiredRateYaw;
float ErrorRateRoll, ErrorRatePitch, ErrorRateYaw;
float InputRoll, InputThrottle, InputPitch, InputYaw;
float PrevErrorRateRoll = 0, PrevErrorRatePitch = 0, PrevErrorRateYaw = 0;
float PrevItermRateRoll = 0, PrevItermRatePitch = 0, PrevItermRateYaw = 0;
float PIDReturn[] = {0, 0, 0};

// PID constants (tune these values as necessary)
float PRateRoll = 0.6, IRateRoll = 3.5, DRateRoll = 0.03;
float PRatePitch = 0.6, IRatePitch = 3.5, DRatePitch = 0.03;
float PRateYaw = 2.0, IRateYaw = 12.0, DRateYaw = 0.0;

// Motor inputs
float MotorInput1, MotorInput2, MotorInput3, MotorInput4;

// Calibration variables
float accXOffset = 0, accYOffset = 0, accZOffset = 0;
float gyroXOffset = 0, gyroYOffset = 0, gyroZOffset = 0;


// Function prototypes
void reset_pid(void);
void pid_equation(float Error, float P, float I, float D, float &PrevError, float &PrevIterm);
void calibrateMPU6050();

void batteryVoltageDetection() {
  // Read the battery voltage
  int sensorValue = analogRead(analogPin);
  float voltageOut = (sensorValue * referenceVoltage) / adcMax;
  float batteryVoltage = voltageOut * (R1 + R2) / R2;

  // Send battery voltage to RemoteXY (ensure the RemoteXY interface supports this)
 // RemoteXY.battery_voltage = batteryVoltage;

  // Check if the battery voltage is below the safe threshold
  if (batteryVoltage < lowVoltageThreshold) {
    digitalWrite(5, LOW); // Optional: take an action if voltage is low
  } else {
    digitalWrite(5, HIGH); // Optional: normal operation
  }
}

void setup() 
{
  // Initialize RemoteXY
  RemoteXY_Init(); 
  
  // Initialize serial communication
  Serial.begin(115200);  
  
  // Initialize MPU6050 sensor
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MPU6050 Found!");
  
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  
  // Calibrate MPU6050
  calibrateMPU6050();
  
  // Initialize ESCs
  esc1.attach(9);  // Motor 1
  esc2.attach(6);  // Motor 2
  esc3.attach(8);  // Motor 3
  esc4.attach(7);  // Motor 4
  
  // Initialize ESCs with minimum throttle
  esc1.writeMicroseconds(1000);
  esc2.writeMicroseconds(1000);
  esc3.writeMicroseconds(1000);
  esc4.writeMicroseconds(1000);
  
  // Wait 2 seconds to allow the ESCs to recognize the startup condition
  delay(2000); 

  
  // Initialize PID variables
  reset_pid();
}

void loop() 
{
  // Handle RemoteXY input
  RemoteXY_Handler();
  
  // Read sensor data
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  
  // Apply calibration offsets
  float accX = a.acceleration.x - accXOffset;
  float accY = a.acceleration.y - accYOffset;
  float accZ = a.acceleration.z - accZOffset;
  float gyroX = g.gyro.x - gyroXOffset;
  float gyroY = g.gyro.y - gyroYOffset;
  float gyroZ = g.gyro.z - gyroZOffset;
  
  // Calculate angles from accelerometer data
  float accAngleX = atan2(accY, accZ) * 180 / PI;
  float accAngleY = atan2(-accX, sqrt(accY * accY + accZ * accZ)) * 180 / PI;
  
  // Implement a complementary filter
  static float pitch = 0, roll = 0;
  float dt = 0.01; // Assuming loop runs every 10ms
  float alpha = 0.98; // Filter coefficient
  
  // Integrate gyro data
  float gyroRateX = gyroX * 180 / PI; // Convert to degrees per second
  float gyroRateY = gyroY * 180 / PI;
  float gyroRateZ = gyroZ * 180 / PI;
  
  pitch = alpha * (pitch + gyroRateX * dt) + (1 - alpha) * accAngleX;
  roll = alpha * (roll + gyroRateY * dt) + (1 - alpha) * accAngleY;
  
  // Read joystick inputs from RemoteXY
  InputThrottle = map(RemoteXY.joystick_01_y, -100, 100, 1000, 2000); // Adjust as needed
  InputRoll = map(RemoteXY.joystick_01_x, -100, 100, -30, 30);        // Desired roll angle
  InputPitch = map(RemoteXY.joystick_02_y, -100, 100, -30, 30);       // Desired pitch angle
  InputYaw = map(RemoteXY.joystick_02_x, -100, 100, -90, 90);         // Desired yaw rate (degrees per second)
  
  // Compute errors
  ErrorRateRoll = InputRoll - roll;
  ErrorRatePitch = InputPitch - pitch;
  ErrorRateYaw = InputYaw - gyroRateZ; // Compare desired yaw rate with actual gyro rate
  
  // Compute PID outputs
  pid_equation(ErrorRateRoll, PRateRoll, IRateRoll, DRateRoll, PrevErrorRateRoll, PrevItermRateRoll);
  float pidOutputRoll = PIDReturn[0];
  
  pid_equation(ErrorRatePitch, PRatePitch, IRatePitch, DRatePitch, PrevErrorRatePitch, PrevItermRatePitch);
  float pidOutputPitch = PIDReturn[0];
  
  pid_equation(ErrorRateYaw, PRateYaw, IRateYaw, DRateYaw, PrevErrorRateYaw, PrevItermRateYaw);
  float pidOutputYaw = PIDReturn[0];
  
  // Calculate motor outputs
  // Assuming quadcopter in X configuration
  MotorInput1 = InputThrottle - pidOutputRoll + pidOutputPitch - pidOutputYaw; // Front Left
  MotorInput2 = InputThrottle - pidOutputRoll - pidOutputPitch + pidOutputYaw; // Front Right
  MotorInput3 = InputThrottle + pidOutputRoll - pidOutputPitch - pidOutputYaw; // Rear Right
  MotorInput4 = InputThrottle + pidOutputRoll + pidOutputPitch + pidOutputYaw; // Rear Left
  
  // Constrain motor outputs
  MotorInput1 = constrain(MotorInput1, 1000, 2000);
  MotorInput2 = constrain(MotorInput2, 1000, 2000);
  MotorInput3 = constrain(MotorInput3, 1000, 2000);
  MotorInput4 = constrain(MotorInput4, 1000, 2000);
  
  // Write motor outputs
  esc1.writeMicroseconds(MotorInput1);
  esc2.writeMicroseconds(MotorInput2);
  esc3.writeMicroseconds(MotorInput3);
  esc4.writeMicroseconds(MotorInput4);
  
  // For debugging
  Serial.print("Pitch: "); Serial.print(pitch);
  Serial.print(", Roll: "); Serial.print(roll);
  Serial.print(", Gyro: "); Serial.print(gyroRateZ);
  Serial.print(", Motor1: "); Serial.print(MotorInput1);
  Serial.print(", Motor2: "); Serial.print(MotorInput2);
  Serial.print(", Motor3: "); Serial.print(MotorInput3);
  Serial.print(", Motor4: "); Serial.println(MotorInput4);
  
  // Delay for loop timing
  delay(10); // 10ms delay for 100Hz update rate
}

// PID function
void pid_equation(float Error, float P, float I, float D, float &PrevError, float &PrevIterm) {
  float dt = 0.01; // Time step (10ms)
  float Pterm = P * Error;
  float Iterm = PrevIterm + I * Error * dt;
  float Dterm = D * (Error - PrevError) / dt;
  
  // Anti-windup for integral term
  Iterm = constrain(Iterm, -400, 400);
  
  float PIDOutput = Pterm + Iterm + Dterm;
  
  // Constrain PID output
  PIDOutput = constrain(PIDOutput, -400, 400);
  
  // Update return values
  PIDReturn[0] = PIDOutput;
  PIDReturn[1] = Error;
  PIDReturn[2] = Iterm;
  
  // Update previous error and integral term
  PrevError = Error;
  PrevIterm = Iterm;
}

// Reset PID variables
void reset_pid(void) {
  PrevErrorRateRoll = PrevErrorRatePitch = PrevErrorRateYaw = 0;
  PrevItermRateRoll = PrevItermRatePitch = PrevItermRateYaw = 0;
}

// Calibration function
void calibrateMPU6050() {
  Serial.println("Calibrating MPU6050...");
  
  const int calibrationSamples = 1000;
  float accXSum = 0, accYSum = 0, accZSum = 0;
  float gyroXSum = 0, gyroYSum = 0, gyroZSum = 0;
  
  for (int i = 0; i < calibrationSamples; i++) {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);
    
    accXSum += a.acceleration.x;
    accYSum += a.acceleration.y;
    accZSum += a.acceleration.z - 9.80665; // Subtract gravity
    
    gyroXSum += g.gyro.x;
    gyroYSum += g.gyro.y;
    gyroZSum += g.gyro.z;
    
    delay(3); // Wait for sensor to stabilize
  }
  
  accXOffset = accXSum / calibrationSamples;
  accYOffset = accYSum / calibrationSamples;
  accZOffset = accZSum / calibrationSamples;
  gyroXOffset = gyroXSum / calibrationSamples;
  gyroYOffset = gyroYSum / calibrationSamples;
  gyroZOffset = gyroZSum / calibrationSamples;
  
  Serial.println("Calibration complete.");
}
